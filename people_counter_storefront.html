<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô</title>
    <script src="p5.min.js"></script>
    <script src="ml5.min.js"></script>
    <!-- Chart.js for analytics -->
    <script src="chart.js"></script>
    <!-- SheetJS for Excel export -->
    <script src="xlsx.full.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        color: white;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5rem;
        font-weight: 700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        margin-bottom: 10px;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        border: 1px solid rgba(255, 255, 255, 0.18);
        max-width: 1400px;
        width: 100%;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 30px;
        align-items: center;
        justify-content: center;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
      }

      .control-group label {
        font-size: 0.9rem;
        font-weight: 600;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }

      select,
      button,
      input {
        padding: 12px 20px;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.9);
        color: #333;
      }

      select:hover,
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .btn-primary {
        background: linear-gradient(45deg, #4caf50, #45a049);
        color: white;
      }

      .btn-success {
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
      }

      .btn-warning {
        background: linear-gradient(45deg, #ffc107, #fd7e14);
        color: white;
      }

      .btn-danger {
        background: linear-gradient(45deg, #dc3545, #c82333);
        color: white;
      }

      .btn-info {
        background: linear-gradient(45deg, #17a2b8, #138496);
        color: white;
      }

      .camera-container {
        display: flex;
        justify-content: center;
        margin-bottom: 30px;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      .stats-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 30px;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(5px);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: transform 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-5px);
      }

      .stat-number {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 5px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .stat-label {
        font-size: 1rem;
        opacity: 0.9;
        font-weight: 500;
      }

      .status {
        text-align: center;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        font-weight: 600;
        font-size: 1.1rem;
      }

      .status.loading {
        background: rgba(255, 193, 7, 0.2);
        border: 1px solid rgba(255, 193, 7, 0.5);
      }

      .status.ready {
        background: rgba(40, 167, 69, 0.2);
        border: 1px solid rgba(40, 167, 69, 0.5);
      }

      .status.error {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid rgba(220, 53, 69, 0.5);
      }

      .analytics-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }

      .chart-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        height: 300px;
      }

      .activity-log {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        max-height: 300px;
        overflow-y: auto;
      }

      .log-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        margin-bottom: 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border-left: 4px solid #4caf50;
      }

      .log-time {
        font-size: 0.9rem;
        opacity: 0.8;
      }

      .log-action {
        font-weight: bold;
        color: #4caf50;
      }

      .direction-indicator {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        font-size: 0.9rem;
        max-width: 200px;
      }

      .counting-line {
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, transparent, #ff4444, transparent);
        z-index: 10;
      }

      .line-adjustment-mode {
        background: rgba(255, 255, 0, 0.1);
        border: 2px dashed #ffff00;
      }

      .line-coordinates {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.8rem;
        color: #ffff00;
      }

      .hourly-stats {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }

      .hourly-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 15px;
      }

      .hour-card {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .hour-time {
        font-size: 0.9rem;
        opacity: 0.8;
        margin-bottom: 5px;
      }

      .hour-count {
        font-size: 1.5rem;
        font-weight: bold;
        color: #4caf50;
      }

      @media (max-width: 768px) {
        .header h1 {
          font-size: 2rem;
        }

        .container {
          padding: 20px;
        }

        .controls {
          flex-direction: column;
        }

        .analytics-section {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>üö∂‚Äç‚ôÇÔ∏è ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô</h1>
      <p>‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à‡∏Ñ‡πâ‡∏≤‡∏õ‡∏•‡∏µ‡∏Å</p>
    </div>

    <div class="container">
      <div class="controls">
        <div class="control-group">
          <label>üì∑ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á</label>
          <select id="cameraSelect">
            <option value="">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Å‡∏•‡πâ‡∏≠‡∏á...</option>
          </select>
        </div>

        <div class="control-group">
          <label>üéØ ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö</label>
          <select id="sensitivity">
            <option value="0.1">‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (10%) - ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á</option>
            <option value="0.2">‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å (20%) - ‡πÑ‡∏ß‡∏°‡∏≤‡∏Å</option>
            <option value="0.3">‡∏™‡∏π‡∏á (30%) - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢</option>
            <option value="0.4">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á+ (40%) - ‡πÑ‡∏ß‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á</option>
            <option value="0.5" selected>‡∏õ‡∏Å‡∏ï‡∏¥ (50%) - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</option>
            <option value="0.6">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á- (60%) - ‡∏•‡∏î‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏£‡∏ö‡∏Å‡∏ß‡∏ô</option>
            <option value="0.7">‡∏ï‡πà‡∏≥ (70%) - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏ô‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</option>
            <option value="0.8">‡∏ï‡πà‡∏≥‡∏°‡∏≤‡∏Å (80%) - ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á</option>
            <option value="0.9">‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î (90%) - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡πà‡πÉ‡∏à</option>
          </select>
        </div>

        <div class="control-group">
          <label>üíæ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</label>
          <select id="recordingThreshold">
            <option value="0.1">‡∏ï‡πà‡∏≥ (10%) - ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏á‡πà‡∏≤‡∏¢</option>
            <option value="0.4">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á- (40%) - ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô</option>
            <option value="0.5" selected>‡∏õ‡∏Å‡∏ï‡∏¥ (50%) - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</option>
            <option value="0.6">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á+ (60%) - ‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á</option>
            <option value="0.7">‡∏™‡∏π‡∏á (70%) - ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î</option>
            <option value="0.8">‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å (80%) - ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î</option>
            <option value="0.9">‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (90%) - ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏°‡∏≤‡∏Å</option>
          </select>
        </div>

        <div class="control-group">
          <label>üìè ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°</label>
          <select id="trackingDistance">
            <option value="50">‡πÉ‡∏Å‡∏•‡πâ (50px) - ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏™‡∏π‡∏á</option>
            <option value="75">‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (75px) - ‡∏™‡∏°‡∏î‡∏∏‡∏•</option>
            <option value="100" selected>‡∏õ‡∏Å‡∏ï‡∏¥ (100px) - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</option>
            <option value="125">‡πÑ‡∏Å‡∏• (125px) - ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô</option>
            <option value="150">‡πÑ‡∏Å‡∏•‡∏°‡∏≤‡∏Å (150px) - ‡∏ú‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏ô</option>
          </select>
        </div>

        <div class="control-group">
          <label>‚ö° ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö</label>
          <select id="detectionSpeed">
            <option value="10">‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏∏‡∏î (10ms) - ‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå</option>
            <option value="100" selected>‡πÄ‡∏£‡πá‡∏ß (100ms) - ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</option>
            <option value="200">‡∏õ‡∏Å‡∏ï‡∏¥ (200ms) - ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</option>
            <option value="500">‡∏ä‡πâ‡∏≤ (500ms) - ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡∏°‡∏≤‡∏Å</option>
          </select>
        </div>

        <div class="control-group">
          <label>üìè ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö</label>
          <select id="lineOrientation">
            <option value="horizontal" selected>‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô</option>
            <option value="vertical">‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á</option>
          </select>
        </div>

        <div class="control-group">
          <label>üìç ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö</label>
          <select id="linePosition">
            <option value="center" selected>‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á</option>
            <option value="start">‡∏ï‡πâ‡∏ô (‡∏ö‡∏ô/‡∏ã‡πâ‡∏≤‡∏¢)</option>
            <option value="end">‡∏õ‡∏•‡∏≤‡∏¢ (‡∏•‡πà‡∏≤‡∏á/‡∏Ç‡∏ß‡∏≤)</option>
          </select>
        </div>

        <div class="control-group">
          <label>üîÑ ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö</label>
          <select id="directionMapping">
            <option value="default" selected>‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏õ‡∏Å‡∏ï‡∏¥</option>
            <option value="reverse">‡∏™‡∏•‡∏±‡∏ö‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á</option>
          </select>
        </div>

        <button id="adjustLineBtn" class="btn-info" style="display: none">
          üéØ ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏°‡∏≤‡∏™‡πå
        </button>

        <button id="startBtn" class="btn-primary">üé¨ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô</button>
        <button id="pauseBtn" class="btn-warning" style="display: none">
          ‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
        </button>
        <button id="resetBtn" class="btn-danger">üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</button>
        <button id="exportBtn" class="btn-success" style="display: none">
          üìä ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô
        </button>
      </div>

      <div id="status" class="status loading">üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö...</div>

      <div class="camera-container">
        <div id="videoContainer"></div>
        <div class="direction-indicator">
          <div>üî¥ ‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô (‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô)</div>
          <div>‚¨áÔ∏è ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô | ‚¨ÜÔ∏è ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô</div>
          <div style="font-size: 0.8rem; opacity: 0.8">Y: 300</div>
        </div>
      </div>

      <div class="stats-container">
        <div class="stat-card">
          <div class="stat-number" id="totalPeople">0</div>
          <div class="stat-label">üë• ‡∏Ñ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="peopleIn">0</div>
          <div class="stat-label">‚û°Ô∏è ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="peopleOut">0</div>
          <div class="stat-label">‚¨ÖÔ∏è ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="currentInside">0</div>
          <div class="stat-label">üè™ ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="peakHour">-</div>
          <div class="stat-label">‚è∞ ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏¢‡∏≠‡∏î‡∏ô‡∏¥‡∏¢‡∏°</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="avgPerHour">0</div>
          <div class="stat-label">üìà ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢/‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á</div>
        </div>
      </div>

      <div class="analytics-section">
        <div class="chart-container">
          <canvas id="trafficChart"></canvas>
        </div>

        <div class="activity-log">
          <h3 style="margin-bottom: 15px; text-align: center">
            üìã ‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
          </h3>
          <div id="activityLog"></div>
        </div>
      </div>

      <div class="hourly-stats">
        <h3 style="text-align: center; margin-bottom: 15px">
          üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏≤‡∏¢‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        </h3>
        <div class="hourly-grid" id="hourlyGrid"></div>
      </div>
    </div>

    <script>
      let video;
      let detector;
      let detections = [];
      let isDetecting = false;
      let isPaused = false;
      let sessionStartTime = null;
      let sensitivity = 0.1;
      let linePosition = "center";
      let lineOrientation = "horizontal";

      // People tracking
      let trackedPeople = [];
      let peopleIdCounter = 0;
      let countingLineY = 300;
      let countingLineX = 400;
      let recordingThreshold = 0.1; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

      // Line adjustment
      let isAdjustingLine = false;
      let lineAdjustmentMode = false;

      // Statistics
      let totalPeopleCount = 0;
      let peopleInCount = 0;
      let peopleOutCount = 0;
      let currentInsideCount = 0;
      let hourlyData = {};
      let activityLog = [];
      let trafficChart = null;

      // Direction mapping
      let directionMapping = 'default';

      // Elements
      const statusEl = document.getElementById("status");
      const totalPeopleEl = document.getElementById("totalPeople");
      const peopleInEl = document.getElementById("peopleIn");
      const peopleOutEl = document.getElementById("peopleOut");
      const currentInsideEl = document.getElementById("currentInside");
      const peakHourEl = document.getElementById("peakHour");
      const avgPerHourEl = document.getElementById("avgPerHour");
      const startBtn = document.getElementById("startBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const resetBtn = document.getElementById("resetBtn");
      const exportBtn = document.getElementById("exportBtn");
      const adjustLineBtn = document.getElementById("adjustLineBtn");
      const cameraSelect = document.getElementById("cameraSelect");
      const sensitivitySelect = document.getElementById("sensitivity");
      const linePositionSelect = document.getElementById("linePosition");
      const lineOrientationSelect = document.getElementById("lineOrientation");
      const recordingThresholdSelect =
        document.getElementById("recordingThreshold");
      const activityLogEl = document.getElementById("activityLog");
      const hourlyGridEl = document.getElementById("hourlyGrid");
      const directionMappingSelect = document.getElementById('directionMapping');

      function preload() {
        // ml5.js will be loaded
      }

      function setup() {
        const canvas = createCanvas(800, 600);
        canvas.parent("videoContainer");

        updateStatus("loading", "üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á...");

        // Initialize hourly data
        initializeHourlyData();

        // Get available cameras
        getCameras();

        // Event listeners
        startBtn.onclick = startCamera;
        pauseBtn.onclick = togglePause;
        resetBtn.onclick = resetData;
        exportBtn.onclick = exportReport;
        adjustLineBtn.onclick = toggleLineAdjustment;

        sensitivitySelect.onchange = (e) => {
          sensitivity = parseFloat(e.target.value);
        };

        recordingThresholdSelect.onchange = (e) => {
          recordingThreshold = parseFloat(e.target.value);
        };

        linePositionSelect.onchange = (e) => {
          linePosition = e.target.value;
          updateCountingLine();
        };

        lineOrientationSelect.onchange = (e) => {
          lineOrientation = e.target.value;
          updateCountingLine();
          updateDirectionIndicator();
        };

        directionMappingSelect.onchange = (e) => {
          directionMapping = e.target.value;
          updateDirectionIndicator();
        };

        // Initialize chart
        initializeChart();

        // Update displays every second
        setInterval(updateDisplays, 1000);
      }

      function initializeHourlyData() {
        for (let i = 0; i < 24; i++) {
          hourlyData[i] = { in: 0, out: 0, total: 0 };
        }
      }

      function updateCountingLine() {
        if (lineOrientation === "horizontal") {
          switch (linePosition) {
            case "start": // top
              countingLineY = 150;
              break;
            case "end": // bottom
              countingLineY = 450;
              break;
            default: // center
              countingLineY = 300;
          }
        } else {
          // vertical
          switch (linePosition) {
            case "start": // left
              countingLineX = 200;
              break;
            case "end": // right
              countingLineX = 600;
              break;
            default: // center
              countingLineX = 400;
          }
        }
      }

      function updateDirectionIndicator() {
        const indicator = document.querySelector(".direction-indicator");
        if (indicator) {
          if (lineOrientation === "horizontal") {
            indicator.innerHTML = `
                        <div>üî¥ ‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô (‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô)</div>
                        <div>‚¨áÔ∏è ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô | ‚¨ÜÔ∏è ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô</div>
                        <div style="font-size: 0.8rem; opacity: 0.8;">Y: ${countingLineY}</div>
                    `;
          } else {
            indicator.innerHTML = `
                        <div>üî¥ ‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô (‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á)</div>
                        <div>‚û°Ô∏è ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô | ‚¨ÖÔ∏è ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô</div>
                        <div style="font-size: 0.8rem; opacity: 0.8;">X: ${countingLineX}</div>
                    `;
          }
        }
      }

      async function getCameras() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(
            (device) => device.kind === "videoinput"
          );

          cameraSelect.innerHTML = "";
          videoDevices.forEach((device, index) => {
            const option = document.createElement("option");
            option.value = device.deviceId;
            option.textContent = device.label || `‡∏Å‡∏•‡πâ‡∏≠‡∏á ${index + 1}`;
            cameraSelect.appendChild(option);
          });

          if (videoDevices.length === 0) {
            cameraSelect.innerHTML = '<option value="">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á</option>';
          }
        } catch (error) {
          console.error("Error getting cameras:", error);
          cameraSelect.innerHTML =
            '<option value="">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</option>';
        }
      }

      async function startCamera() {
        try {
          updateStatus("loading", "üé¨ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á...");

          const constraints = {
            video: {
              width: 800,
              height: 600,
              deviceId: cameraSelect.value
                ? { exact: cameraSelect.value }
                : undefined,
            },
          };

          video = createCapture(constraints);
          video.size(800, 600);
          video.hide();

          // Wait for video to be ready
          video.elt.addEventListener("loadeddata", initializeDetector);

          startBtn.style.display = "none";
          pauseBtn.style.display = "inline-block";
          exportBtn.style.display = "inline-block";
          adjustLineBtn.style.display = "inline-block";
        } catch (error) {
          console.error("Error starting camera:", error);
          updateStatus("error", "‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á");
        }
      }

      function initializeDetector() {
        updateStatus("loading", "ü§ñ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î AI Model...");

        detector = ml5.objectDetector("cocossd", {}, () => {
          updateStatus("ready", "‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô! ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô");
          isDetecting = true;
          sessionStartTime = new Date();
          updateCountingLine();
          updateDirectionIndicator();
          detect();
        });
      }

      function detect() {
        if (!isDetecting || !video || isPaused) {
          if (isDetecting && !isPaused) {
            setTimeout(detect, 100);
          }
          return;
        }

        detector.detect(video, (error, results) => {
          if (error) {
            console.error("Detection error:", error);
            return;
          }

          // Filter for people only
          const people = results.filter(
            (detection) =>
              detection.label.toLowerCase() === "person" &&
              detection.confidence >= sensitivity
          );

          detections = people;
          trackPeople(people);
          setTimeout(detect, 100);
        });
      }

      function trackPeople(currentPeople) {
        const maxDistance = 100;
        const newTrackedPeople = [];

        currentPeople.forEach((person) => {
          const centerX = person.x + person.width / 2;
          const centerY = person.y + person.height / 2;

          // Find closest existing tracked person
          let closestPerson = null;
          let minDistance = maxDistance;

          trackedPeople.forEach((tracked) => {
            const distance = dist(centerX, centerY, tracked.x, tracked.y);
            if (distance < minDistance) {
              minDistance = distance;
              closestPerson = tracked;
            }
          });

          if (closestPerson) {
            // Update existing person
            const updatedPerson = {
              id: closestPerson.id,
              x: centerX,
              y: centerY,
              prevX: closestPerson.x,
              prevY: closestPerson.y,
              confidence: person.confidence,
              crossedLine: closestPerson.crossedLine,
              direction: closestPerson.direction,
            };

            // Check line crossing
            checkLineCrossing(updatedPerson);
            newTrackedPeople.push(updatedPerson);
          } else {
            // Create new tracked person
            newTrackedPeople.push({
              id: peopleIdCounter++,
              x: centerX,
              y: centerY,
              prevX: centerY,
              prevY: centerY,
              confidence: person.confidence,
              crossedLine: false,
              direction: null,
            });
          }
        });

        trackedPeople = newTrackedPeople;
      }

      function checkLineCrossing(person) {
        if (person.crossedLine) return;

        const tolerance = 20;
        let crossed = false;
        let direction = null;

        if (lineOrientation === "horizontal") {
          if (directionMapping === 'default') {
            // Moving down = entering, Moving up = leaving
            if (person.prevY < countingLineY && person.y > countingLineY) {
              direction = "in";
            } else if (person.prevY > countingLineY && person.y < countingLineY) {
              direction = "out"; 
            }
          } else {
            // Reversed: Moving down = leaving, Moving up = entering
            if (person.prevY < countingLineY && person.y > countingLineY) {
              direction = "out";
            } else if (person.prevY > countingLineY && person.y < countingLineY) {
              direction = "in";
            }
          }
        } else {
          // vertical
          const lineX = countingLineX;

          // Check if person crossed the vertical line
          if (
            (person.prevX < lineX - tolerance &&
              person.x > lineX + tolerance) ||
            (person.prevX > lineX + tolerance && person.x < lineX - tolerance)
          ) {
            crossed = true;

            // Determine direction for vertical line
            if (person.prevX < lineX && person.x > lineX) {
              // Moving right (entering store)
              direction = "in";
            } else if (person.prevX > lineX && person.x < lineX) {
              // Moving left (leaving store)
              direction = "out";
            }
          }
        }

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        if (crossed && direction && person.confidence >= recordingThreshold) {
          person.crossedLine = true;
          person.direction = direction;

          if (direction === "in") {
            peopleInCount++;
            currentInsideCount++;
            logActivity("‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô", "in", person.confidence);
          } else {
            peopleOutCount++;
            currentInsideCount = Math.max(0, currentInsideCount - 1);
            logActivity("‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô", "out", person.confidence);
          }

          totalPeopleCount++;
          updateHourlyData(person.direction);
          updateStats();
        } else if (
          crossed &&
          direction &&
          person.confidence < recordingThreshold
        ) {
          // ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
          console.log(
            `‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏™‡πâ‡∏ô ‡πÅ‡∏ï‡πà‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ï‡πà‡∏≥ (${Math.round(
              person.confidence * 100
            )}%) - ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å`
          );
        }
      }

      function logActivity(action, direction, confidence) {
        const timestamp = new Date();
        activityLog.unshift({
          time: timestamp,
          action: action,
          direction: direction,
          confidence: confidence,
        });

        // Keep only last 50 activities
        if (activityLog.length > 50) {
          activityLog = activityLog.slice(0, 50);
        }

        updateActivityLog();
      }

      function updateHourlyData(direction) {
        const hour = new Date().getHours();
        if (direction === "in") {
          hourlyData[hour].in++;
        } else if (direction === "out") {
          hourlyData[hour].out++;
        }
        hourlyData[hour].total++;

        updateHourlyDisplay();
        updateChart();
      }

      function updateStats() {
        totalPeopleEl.textContent = totalPeopleCount;
        peopleInEl.textContent = peopleInCount;
        peopleOutEl.textContent = peopleOutCount;
        currentInsideEl.textContent = currentInsideCount;

        // Calculate peak hour
        let peakHour = 0;
        let maxCount = 0;
        Object.entries(hourlyData).forEach(([hour, data]) => {
          if (data.total > maxCount) {
            maxCount = data.total;
            peakHour = parseInt(hour);
          }
        });

        if (maxCount > 0) {
          peakHourEl.textContent = `${peakHour}:00-${peakHour + 1}:00`;
        }

        // Calculate average per hour
        if (sessionStartTime) {
          const hoursElapsed =
            (new Date() - sessionStartTime) / (1000 * 60 * 60);
          if (hoursElapsed > 0) {
            avgPerHourEl.textContent = Math.round(
              totalPeopleCount / hoursElapsed
            );
          }
        }
      }

      function updateActivityLog() {
        activityLogEl.innerHTML = "";

        activityLog.slice(0, 10).forEach((activity) => {
          const logItem = document.createElement("div");
          logItem.className = "log-item";

          const icon = activity.direction === "in" ? "‚û°Ô∏è" : "‚¨ÖÔ∏è";
          const color = activity.direction === "in" ? "#4CAF50" : "#ff9800";
          const confidencePercent = Math.round(activity.confidence * 100);

          // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à
          let confidenceColor = "#4CAF50"; // ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
          if (confidencePercent < 60) confidenceColor = "#ff4444"; // ‡πÅ‡∏î‡∏á
          else if (confidencePercent < 80) confidenceColor = "#ff9800"; // ‡∏™‡πâ‡∏°

          logItem.innerHTML = `
                    <div class="log-action" style="color: ${color};">
                        ${icon} ${activity.action}
                        <span style="font-size: 0.8rem; color: ${confidenceColor}; margin-left: 5px;">
                            (${confidencePercent}%)
                        </span>
                    </div>
                    <div class="log-time">
                        ${activity.time.toLocaleTimeString("th-TH")}
                    </div>
                `;

          activityLogEl.appendChild(logItem);
        });

        if (activityLog.length === 0) {
          activityLogEl.innerHTML =
            '<div style="text-align: center; opacity: 0.7;">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°</div>';
        }
      }

      function updateHourlyDisplay() {
        hourlyGridEl.innerHTML = "";

        for (let hour = 0; hour < 24; hour++) {
          const hourCard = document.createElement("div");
          hourCard.className = "hour-card";

          const data = hourlyData[hour];
          const isCurrentHour = new Date().getHours() === hour;

          if (isCurrentHour) {
            hourCard.style.border = "2px solid #4CAF50";
          }

          hourCard.innerHTML = `
                    <div class="hour-time">${hour}:00</div>
                    <div class="hour-count">${data.total}</div>
                    <div style="font-size: 0.8rem; opacity: 0.8;">
                        ‚ÜóÔ∏è${data.in} ‚ÜôÔ∏è${data.out}
                    </div>
                `;

          hourlyGridEl.appendChild(hourCard);
        }
      }

      function initializeChart() {
        const ctx = document.getElementById("trafficChart").getContext("2d");
        trafficChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
            datasets: [
              {
                label: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô",
                data: Array(24).fill(0),
                borderColor: "#4CAF50",
                backgroundColor: "rgba(76, 175, 80, 0.1)",
                tension: 0.4,
              },
              {
                label: "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô",
                data: Array(24).fill(0),
                borderColor: "#ff9800",
                backgroundColor: "rgba(255, 152, 0, 0.1)",
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: "‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á",
                color: "white",
              },
              legend: {
                labels: {
                  color: "white",
                },
              },
            },
            scales: {
              x: {
                ticks: { color: "white" },
                grid: { color: "rgba(255, 255, 255, 0.1)" },
              },
              y: {
                ticks: { color: "white" },
                grid: { color: "rgba(255, 255, 255, 0.1)" },
              },
            },
          },
        });
      }

      function updateChart() {
        if (trafficChart) {
          const inData = Array.from({ length: 24 }, (_, i) => hourlyData[i].in);
          const outData = Array.from(
            { length: 24 },
            (_, i) => hourlyData[i].out
          );

          trafficChart.data.datasets[0].data = inData;
          trafficChart.data.datasets[1].data = outData;
          trafficChart.update();
        }
      }

      function toggleLineAdjustment() {
        lineAdjustmentMode = !lineAdjustmentMode;

        if (lineAdjustmentMode) {
          adjustLineBtn.textContent = "‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô";
          adjustLineBtn.className = "btn-success";
          updateStatus("ready", "üéØ ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡∏∞‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö");

          // Add visual indicator
          const videoContainer = document.getElementById("videoContainer");
          videoContainer.classList.add("line-adjustment-mode");
        } else {
          adjustLineBtn.textContent = "üéØ ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏°‡∏≤‡∏™‡πå";
          adjustLineBtn.className = "btn-info";
          updateStatus("ready", "‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß");

          // Remove visual indicator
          const videoContainer = document.getElementById("videoContainer");
          videoContainer.classList.remove("line-adjustment-mode");
        }
      }

      function mousePressed() {
        if (
          lineAdjustmentMode &&
          mouseX >= 0 &&
          mouseX <= 800 &&
          mouseY >= 0 &&
          mouseY <= 600
        ) {
          isAdjustingLine = true;

          if (lineOrientation === "horizontal") {
            countingLineY = mouseY;
          } else {
            countingLineX = mouseX;
          }

          updateDirectionIndicator();
        }
      }

      function mouseDragged() {
        if (
          lineAdjustmentMode &&
          isAdjustingLine &&
          mouseX >= 0 &&
          mouseX <= 800 &&
          mouseY >= 0 &&
          mouseY <= 600
        ) {
          if (lineOrientation === "horizontal") {
            countingLineY = mouseY;
          } else {
            countingLineX = mouseX;
          }

          updateDirectionIndicator();
        }
      }

      function mouseReleased() {
        isAdjustingLine = false;
      }

      function updateDisplays() {
        updateHourlyDisplay();
      }

      function togglePause() {
        isPaused = !isPaused;
        if (isPaused) {
          pauseBtn.textContent = "‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≠";
          updateStatus("ready", "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß");
        } else {
          pauseBtn.textContent = "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß";
          updateStatus("ready", "‚ñ∂Ô∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô");
          if (isDetecting) detect();
        }
      }

      function resetData() {
        totalPeopleCount = 0;
        peopleInCount = 0;
        peopleOutCount = 0;
        currentInsideCount = 0;
        trackedPeople = [];
        peopleIdCounter = 0;
        activityLog = [];
        initializeHourlyData();
        sessionStartTime = new Date();

        updateStats();
        updateActivityLog();
        updateHourlyDisplay();
        updateChart();
        updateStatus("ready", "üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢");
      }

      function exportReport() {
        const wb = XLSX.utils.book_new();

        // Summary sheet
        const summaryData = [
          ["‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ô‡πÄ‡∏î‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô"],
          ["‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠", new Date().toLocaleString("th-TH")],
          [
            "‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô",
            sessionStartTime
              ? sessionStartTime.toLocaleString("th-TH")
              : "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏",
          ],
          [],
          ["‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏ß‡∏°"],
          ["‡∏Ñ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î", totalPeopleCount],
          ["‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô", peopleInCount],
          ["‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô", peopleOutCount],
          ["‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô", currentInsideCount],
          [],
          ["‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏≤‡∏¢‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á"],
          ["‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á", "‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô", "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô", "‡∏£‡∏ß‡∏°"],
        ];

        for (let hour = 0; hour < 24; hour++) {
          const data = hourlyData[hour];
          summaryData.push([
            `${hour}:00-${hour + 1}:00`,
            data.in,
            data.out,
            data.total,
          ]);
        }

        const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
        XLSX.utils.book_append_sheet(wb, summaryWs, "‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô");

        // Activity log sheet
        if (activityLog.length > 0) {
          const activityData = [["‡πÄ‡∏ß‡∏•‡∏≤", "‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°", "‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á"]];

          activityLog.forEach((activity) => {
            activityData.push([
              activity.time.toLocaleString("th-TH"),
              activity.action,
              activity.direction === "in" ? "‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πâ‡∏≤‡∏ô" : "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô",
            ]);
          });

          const activityWs = XLSX.utils.aoa_to_sheet(activityData);
          XLSX.utils.book_append_sheet(wb, activityWs, "‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î");
        }

        // Export file
        const timestamp = new Date()
          .toISOString()
          .slice(0, 19)
          .replace(/:/g, "-");
        const fileName = `people_counter_report_${timestamp}.xlsx`;

        XLSX.writeFile(wb, fileName);

        updateStatus("ready", "üìä ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!");
      }

      function draw() {
        if (video && video.loadedmetadata) {
          // Draw video
          image(video, 0, 0, 800, 600);

          // Draw counting line
          stroke(255, 68, 68);
          strokeWeight(lineAdjustmentMode ? 5 : 3);

          if (lineOrientation === "horizontal") {
            line(0, countingLineY, 800, countingLineY);

            // Draw line markers
            if (lineAdjustmentMode) {
              fill(255, 68, 68);
              noStroke();
              triangle(
                10,
                countingLineY - 10,
                10,
                countingLineY + 10,
                25,
                countingLineY
              );
              triangle(
                790,
                countingLineY - 10,
                790,
                countingLineY + 10,
                775,
                countingLineY
              );
            }
          } else {
            line(countingLineX, 0, countingLineX, 600);

            // Draw line markers
            if (lineAdjustmentMode) {
              fill(255, 68, 68);
              noStroke();
              triangle(
                countingLineX - 10,
                10,
                countingLineX + 10,
                10,
                countingLineX,
                25
              );
              triangle(
                countingLineX - 10,
                590,
                countingLineX + 10,
                590,
                countingLineX,
                575
              );
            }
          }

          // Draw detection boxes for people
          detections.forEach((person) => {
            const x = person.x;
            const y = person.y;
            const w = person.width;
            const h = person.height;

            // Draw bounding box
            stroke(76, 175, 80);
            strokeWeight(2);
            noFill();
            rect(x, y, w, h);

            // Draw label
            fill(76, 175, 80);
            noStroke();
            textAlign(LEFT, TOP);
            textSize(14);
            const label = `Person ${Math.round(person.confidence * 100)}%`;

            // Background for text
            fill(0, 0, 0, 150);
            rect(x, y - 20, textWidth(label) + 10, 20);

            // Text
            fill(255, 255, 255);
            text(label, x + 5, y - 18);
          });

          // Draw tracked people paths
          trackedPeople.forEach((person) => {
            stroke(255, 255, 0, 150);
            strokeWeight(2);
            line(person.prevX, person.prevY, person.x, person.y);

            // Draw person center point
            fill(255, 255, 0);
            noStroke();
            ellipse(person.x, person.y, 8, 8);

            // Draw ID
            fill(255, 255, 255);
            textAlign(CENTER, CENTER);
            textSize(12);
            text(person.id, person.x, person.y - 15);
          });

          // Draw line coordinates when adjusting
          if (lineAdjustmentMode) {
            fill(255, 255, 0);
            noStroke();
            textAlign(RIGHT, TOP);
            textSize(14);

            if (lineOrientation === "horizontal") {
              text(`Y: ${Math.round(countingLineY)}`, width - 10, 10);
            } else {
              text(`X: ${Math.round(countingLineX)}`, width - 10, 10);
            }

            // Draw adjustment instructions
            textAlign(CENTER, BOTTOM);
            textSize(16);
            fill(255, 255, 0, 200);
            text(
              "üéØ ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡∏∞‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ô‡∏±‡∏ö",
              width / 2,
              height - 20
            );
          }

          // Draw pause indicator
          if (isPaused) {
            fill(255, 193, 7, 100);
            noStroke();
            rect(0, 0, width, height);

            fill(255, 255, 255);
            textAlign(CENTER, CENTER);
            textSize(24);
            text("‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß", width / 2, height / 2);
          }
        } else {
          // Show loading screen
          background(50);
          fill(255);
          textAlign(CENTER, CENTER);
          textSize(24);
          text("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...", width / 2, height / 2);
        }
      }

      function updateStatus(type, message) {
        statusEl.className = `status ${type}`;
        statusEl.textContent = message;
      }

      // Initialize p5.js
      new p5();
    </script>
  </body>
</html>
